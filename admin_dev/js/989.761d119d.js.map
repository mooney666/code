{"version":3,"file":"js/989.761d119d.js","mappings":"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","sources":["webpack://web_admin/../../../../packages/components/form/src/form.ts","webpack://web_admin/./node_modules/lodash-es/castArray.js","webpack://web_admin/../../../../packages/components/form/src/utils.ts","webpack://web_admin/../../../../packages/components/form/src/form.vue","webpack://web_admin/./node_modules/lodash-es/clone.js","webpack://web_admin/../../../../packages/components/form/src/form-item.ts","webpack://web_admin/../../../../packages/components/form/src/form-label-wrap.tsx","webpack://web_admin/../../../../packages/components/form/src/form-item.vue","webpack://web_admin/../../../../packages/components/form/index.ts","webpack://web_admin/../../../../packages/utils/dom/aria.ts"],"sourcesContent":["import { componentSizes } from '@element-plus/constants'\nimport {\n  buildProps,\n  definePropType,\n  isArray,\n  isBoolean,\n  isString,\n} from '@element-plus/utils'\n\nimport type { ExtractPropTypes } from 'vue'\nimport type { FormItemProp } from './form-item'\nimport type { FormRules } from '@element-plus/tokens'\n\nexport const formProps = buildProps({\n  model: Object,\n  rules: {\n    type: definePropType<FormRules>(Object),\n  },\n  labelPosition: String,\n  labelWidth: {\n    type: [String, Number],\n    default: '',\n  },\n  labelSuffix: {\n    type: String,\n    default: '',\n  },\n  inline: Boolean,\n  inlineMessage: Boolean,\n  statusIcon: Boolean,\n  showMessage: {\n    type: Boolean,\n    default: true,\n  },\n  size: {\n    type: String,\n    values: componentSizes,\n  },\n  disabled: Boolean,\n  validateOnRuleChange: {\n    type: Boolean,\n    default: true,\n  },\n  hideRequiredAsterisk: {\n    type: Boolean,\n    default: false,\n  },\n  scrollToError: Boolean,\n} as const)\nexport type FormProps = ExtractPropTypes<typeof formProps>\n\nexport const formEmits = {\n  validate: (prop: FormItemProp, isValid: boolean, message: string) =>\n    (isArray(prop) || isString(prop)) &&\n    isBoolean(isValid) &&\n    isString(message),\n}\nexport type FormEmits = typeof formEmits\n","import isArray from './isArray.js';\n\n/**\n * Casts `value` as an array if it's not one.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Lang\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast array.\n * @example\n *\n * _.castArray(1);\n * // => [1]\n *\n * _.castArray({ 'a': 1 });\n * // => [{ 'a': 1 }]\n *\n * _.castArray('abc');\n * // => ['abc']\n *\n * _.castArray(null);\n * // => [null]\n *\n * _.castArray(undefined);\n * // => [undefined]\n *\n * _.castArray();\n * // => []\n *\n * var array = [1, 2, 3];\n * console.log(_.castArray(array) === array);\n * // => true\n */\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray(value) ? value : [value];\n}\n\nexport default castArray;\n","import { computed, ref } from 'vue'\nimport { debugWarn, ensureArray } from '@element-plus/utils'\nimport type { Arrayable } from '@element-plus/utils'\nimport type { FormItemContext } from '@element-plus/tokens'\nimport type { FormItemProp } from './form-item'\n\nconst SCOPE = 'ElForm'\n\nexport function useFormLabelWidth() {\n  const potentialLabelWidthArr = ref<number[]>([])\n\n  const autoLabelWidth = computed(() => {\n    if (!potentialLabelWidthArr.value.length) return '0'\n    const max = Math.max(...potentialLabelWidthArr.value)\n    return max ? `${max}px` : ''\n  })\n\n  function getLabelWidthIndex(width: number) {\n    const index = potentialLabelWidthArr.value.indexOf(width)\n    if (index === -1) {\n      debugWarn(SCOPE, `unexpected width ${width}`)\n    }\n    return index\n  }\n\n  function registerLabelWidth(val: number, oldVal: number) {\n    if (val && oldVal) {\n      const index = getLabelWidthIndex(oldVal)\n      potentialLabelWidthArr.value.splice(index, 1, val)\n    } else if (val) {\n      potentialLabelWidthArr.value.push(val)\n    }\n  }\n\n  function deregisterLabelWidth(val: number) {\n    const index = getLabelWidthIndex(val)\n    if (index > -1) {\n      potentialLabelWidthArr.value.splice(index, 1)\n    }\n  }\n\n  return {\n    autoLabelWidth,\n    registerLabelWidth,\n    deregisterLabelWidth,\n  }\n}\n\nexport const filterFields = (\n  fields: FormItemContext[],\n  props: Arrayable<FormItemProp>\n) => {\n  const normalized = ensureArray(props)\n  return normalized.length > 0\n    ? fields.filter((field) => field.prop && normalized.includes(field.prop))\n    : fields\n}\n","<template>\n  <form :class=\"formClasses\">\n    <slot />\n  </form>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed, provide, reactive, toRefs, watch } from 'vue'\nimport { debugWarn, isFunction } from '@element-plus/utils'\nimport { formContextKey } from '@element-plus/tokens'\nimport { useNamespace, useSize } from '@element-plus/hooks'\nimport { formEmits, formProps } from './form'\nimport { filterFields, useFormLabelWidth } from './utils'\n\nimport type { ValidateFieldsError } from 'async-validator'\nimport type { Arrayable } from '@element-plus/utils'\nimport type {\n  FormContext,\n  FormItemContext,\n  FormValidateCallback,\n  FormValidationResult,\n} from '@element-plus/tokens'\nimport type { FormItemProp } from './form-item'\n\nconst COMPONENT_NAME = 'ElForm'\ndefineOptions({\n  name: 'ElForm',\n})\nconst props = defineProps(formProps)\nconst emit = defineEmits(formEmits)\n\nconst fields: FormItemContext[] = []\n\nconst formSize = useSize()\nconst ns = useNamespace('form')\nconst formClasses = computed(() => {\n  const { labelPosition, inline } = props\n  return [\n    ns.b(),\n    // todo: in v2.2.0, we can remove default\n    // in fact, remove it doesn't affect the final style\n    ns.m(formSize.value || 'default'),\n    {\n      [ns.m(`label-${labelPosition}`)]: labelPosition,\n      [ns.m('inline')]: inline,\n    },\n  ]\n})\n\nconst addField: FormContext['addField'] = (field) => {\n  fields.push(field)\n}\n\nconst removeField: FormContext['removeField'] = (field) => {\n  if (field.prop) {\n    fields.splice(fields.indexOf(field), 1)\n  }\n}\n\nconst resetFields: FormContext['resetFields'] = (properties = []) => {\n  if (!props.model) {\n    debugWarn(COMPONENT_NAME, 'model is required for resetFields to work.')\n    return\n  }\n  filterFields(fields, properties).forEach((field) => field.resetField())\n}\n\nconst clearValidate: FormContext['clearValidate'] = (props = []) => {\n  filterFields(fields, props).forEach((field) => field.clearValidate())\n}\n\nconst isValidatable = computed(() => {\n  const hasModel = !!props.model\n  if (!hasModel) {\n    debugWarn(COMPONENT_NAME, 'model is required for validate to work.')\n  }\n  return hasModel\n})\n\nconst obtainValidateFields = (props: Arrayable<FormItemProp>) => {\n  if (fields.length === 0) return []\n\n  const filteredFields = filterFields(fields, props)\n  if (!filteredFields.length) {\n    debugWarn(COMPONENT_NAME, 'please pass correct props!')\n    return []\n  }\n  return filteredFields\n}\n\nconst validate = async (\n  callback?: FormValidateCallback\n): FormValidationResult => validateField(undefined, callback)\n\nconst doValidateField = async (\n  props: Arrayable<FormItemProp> = []\n): Promise<boolean> => {\n  if (!isValidatable.value) return false\n\n  const fields = obtainValidateFields(props)\n  if (fields.length === 0) return true\n\n  let validationErrors: ValidateFieldsError = {}\n  for (const field of fields) {\n    try {\n      await field.validate('')\n    } catch (fields) {\n      validationErrors = {\n        ...validationErrors,\n        ...(fields as ValidateFieldsError),\n      }\n    }\n  }\n\n  if (Object.keys(validationErrors).length === 0) return true\n  return Promise.reject(validationErrors)\n}\n\nconst validateField: FormContext['validateField'] = async (\n  modelProps = [],\n  callback\n) => {\n  const shouldThrow = !isFunction(callback)\n  try {\n    const result = await doValidateField(modelProps)\n    // When result is false meaning that the fields are not validatable\n    if (result === true) {\n      callback?.(result)\n    }\n    return result\n  } catch (e) {\n    const invalidFields = e as ValidateFieldsError\n\n    if (props.scrollToError) {\n      scrollToField(Object.keys(invalidFields)[0])\n    }\n    callback?.(false, invalidFields)\n    return shouldThrow && Promise.reject(invalidFields)\n  }\n}\n\nconst scrollToField = (prop: FormItemProp) => {\n  const field = filterFields(fields, prop)[0]\n  if (field) {\n    field.$el?.scrollIntoView()\n  }\n}\n\nwatch(\n  () => props.rules,\n  () => {\n    if (props.validateOnRuleChange) validate()\n  },\n  { deep: true }\n)\n\nprovide(\n  formContextKey,\n  reactive({\n    ...toRefs(props),\n    emit,\n\n    resetFields,\n    clearValidate,\n    validateField,\n    addField,\n    removeField,\n\n    ...useFormLabelWidth(),\n  })\n)\n\ndefineExpose({\n  /** @description validate form */\n  validate,\n  /** @description validate form field */\n  validateField,\n  /** @description reset fields */\n  resetFields,\n  /** @description clear validation status */\n  clearValidate,\n  /** @description scroll to field */\n  scrollToField,\n})\n</script>\n","import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nexport default clone;\n","import { componentSizes } from '@element-plus/constants'\nimport { buildProps, definePropType } from '@element-plus/utils'\n\nimport type { ExtractPropTypes } from 'vue'\nimport type { Arrayable } from '@element-plus/utils'\nimport type { FormItemRule } from '@element-plus/tokens'\n\nexport const formItemValidateStates = [\n  '',\n  'error',\n  'validating',\n  'success',\n] as const\nexport type FormItemValidateState = typeof formItemValidateStates[number]\n\nexport type FormItemProp = Arrayable<string>\n\nexport const formItemProps = buildProps({\n  label: String,\n  labelWidth: {\n    type: [String, Number],\n    default: '',\n  },\n  prop: {\n    type: definePropType<FormItemProp>([String, Array]),\n  },\n  required: {\n    type: Boolean,\n    default: undefined,\n  },\n  rules: {\n    type: definePropType<Arrayable<FormItemRule>>([Object, Array]),\n  },\n  error: String,\n  validateStatus: {\n    type: String,\n    values: formItemValidateStates,\n  },\n  for: String,\n  inlineMessage: {\n    type: [String, Boolean],\n    default: '',\n  },\n  showMessage: {\n    type: Boolean,\n    default: true,\n  },\n  size: {\n    type: String,\n    values: componentSizes,\n  },\n} as const)\nexport type FormItemProps = ExtractPropTypes<typeof formItemProps>\n","import {\n  Fragment,\n  computed,\n  defineComponent,\n  inject,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  onUpdated,\n  ref,\n  watch,\n} from 'vue'\nimport { useResizeObserver } from '@vueuse/core'\nimport { throwError } from '@element-plus/utils'\nimport { formContextKey, formItemContextKey } from '@element-plus/tokens'\nimport { useNamespace } from '@element-plus/hooks'\n\nimport type { CSSProperties } from 'vue'\n\nconst COMPONENT_NAME = 'ElLabelWrap'\nexport default defineComponent({\n  name: COMPONENT_NAME,\n  props: {\n    isAutoWidth: Boolean,\n    updateAll: Boolean,\n  },\n\n  setup(props, { slots }) {\n    const formContext = inject(formContextKey, undefined)\n    const formItemContext = inject(formItemContextKey)\n    if (!formItemContext)\n      throwError(\n        COMPONENT_NAME,\n        'usage: <el-form-item><label-wrap /></el-form-item>'\n      )\n\n    const ns = useNamespace('form')\n\n    const el = ref<HTMLElement>()\n    const computedWidth = ref(0)\n\n    const getLabelWidth = () => {\n      if (el.value?.firstElementChild) {\n        const width = window.getComputedStyle(el.value.firstElementChild).width\n        return Math.ceil(Number.parseFloat(width))\n      } else {\n        return 0\n      }\n    }\n\n    const updateLabelWidth = (action: 'update' | 'remove' = 'update') => {\n      nextTick(() => {\n        if (slots.default && props.isAutoWidth) {\n          if (action === 'update') {\n            computedWidth.value = getLabelWidth()\n          } else if (action === 'remove') {\n            formContext?.deregisterLabelWidth(computedWidth.value)\n          }\n        }\n      })\n    }\n    const updateLabelWidthFn = () => updateLabelWidth('update')\n\n    onMounted(() => {\n      updateLabelWidthFn()\n    })\n    onBeforeUnmount(() => {\n      updateLabelWidth('remove')\n    })\n    onUpdated(() => updateLabelWidthFn())\n\n    watch(computedWidth, (val, oldVal) => {\n      if (props.updateAll) {\n        formContext?.registerLabelWidth(val, oldVal)\n      }\n    })\n\n    useResizeObserver(\n      computed(\n        () => (el.value?.firstElementChild ?? null) as HTMLElement | null\n      ),\n      updateLabelWidthFn\n    )\n\n    return () => {\n      if (!slots) return null\n\n      const { isAutoWidth } = props\n      if (isAutoWidth) {\n        const autoLabelWidth = formContext?.autoLabelWidth\n        const style: CSSProperties = {}\n        if (autoLabelWidth && autoLabelWidth !== 'auto') {\n          const marginWidth = Math.max(\n            0,\n            Number.parseInt(autoLabelWidth, 10) - computedWidth.value\n          )\n          const marginPosition =\n            formContext.labelPosition === 'left' ? 'marginRight' : 'marginLeft'\n          if (marginWidth) {\n            style[marginPosition] = `${marginWidth}px`\n          }\n        }\n        return (\n          <div ref={el} class={[ns.be('item', 'label-wrap')]} style={style}>\n            {slots.default?.()}\n          </div>\n        )\n      } else {\n        return <Fragment ref={el}>{slots.default?.()}</Fragment>\n      }\n    }\n  },\n})\n","<template>\n  <div ref=\"formItemRef\" :class=\"formItemClasses\">\n    <form-label-wrap\n      :is-auto-width=\"labelStyle.width === 'auto'\"\n      :update-all=\"formContext?.labelWidth === 'auto'\"\n    >\n      <label\n        v-if=\"label || $slots.label\"\n        :for=\"labelFor\"\n        :class=\"ns.e('label')\"\n        :style=\"labelStyle\"\n      >\n        <slot name=\"label\" :label=\"currentLabel\">\n          {{ currentLabel }}\n        </slot>\n      </label>\n    </form-label-wrap>\n\n    <div :class=\"ns.e('content')\" :style=\"contentStyle\">\n      <slot />\n      <transition :name=\"`${ns.namespace.value}-zoom-in-top`\">\n        <slot v-if=\"shouldShowError\" name=\"error\" :error=\"validateMessage\">\n          <div :class=\"validateClasses\">\n            {{ validateMessage }}\n          </div>\n        </slot>\n      </transition>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  inject,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  toRefs,\n  useSlots,\n  watch,\n} from 'vue'\nimport AsyncValidator from 'async-validator'\nimport { clone, isEqual } from 'lodash-unified'\nimport { refDebounced } from '@vueuse/core'\nimport {\n  addUnit,\n  ensureArray,\n  getProp,\n  isBoolean,\n  isFunction,\n  isString,\n} from '@element-plus/utils'\nimport { formContextKey, formItemContextKey } from '@element-plus/tokens'\nimport { useNamespace, useSize } from '@element-plus/hooks'\nimport { formItemProps } from './form-item'\nimport FormLabelWrap from './form-label-wrap'\n\nimport type { CSSProperties } from 'vue'\nimport type { RuleItem } from 'async-validator'\nimport type {\n  FormItemContext,\n  FormItemRule,\n  FormValidateFailure,\n} from '@element-plus/tokens'\nimport type { Arrayable } from '@element-plus/utils'\nimport type { FormItemValidateState } from './form-item'\n\ndefineOptions({\n  name: 'ElFormItem',\n})\nconst props = defineProps(formItemProps)\nconst slots = useSlots()\n\nconst formContext = inject(formContextKey, undefined)\nconst parentFormItemContext = inject(formItemContextKey, undefined)\n\nconst _size = useSize(undefined, { formItem: false })\nconst ns = useNamespace('form-item')\n\nconst validateState = ref<FormItemValidateState>('')\nconst validateStateDebounced = refDebounced(validateState, 100)\nconst validateMessage = ref('')\nconst formItemRef = ref<HTMLDivElement>()\n// special inline value.\nlet initialValue: any = undefined\nlet isResettingField = false\n\nconst labelStyle = computed<CSSProperties>(() => {\n  if (formContext?.labelPosition === 'top') {\n    return {}\n  }\n\n  const labelWidth = addUnit(props.labelWidth || formContext?.labelWidth || '')\n  if (labelWidth) return { width: labelWidth }\n  return {}\n})\n\nconst contentStyle = computed<CSSProperties>(() => {\n  if (formContext?.labelPosition === 'top' || formContext?.inline) {\n    return {}\n  }\n  if (!props.label && !props.labelWidth && isNested) {\n    return {}\n  }\n  const labelWidth = addUnit(props.labelWidth || formContext?.labelWidth || '')\n  if (!props.label && !slots.label) {\n    return { marginLeft: labelWidth }\n  }\n  return {}\n})\n\nconst formItemClasses = computed(() => [\n  ns.b(),\n  ns.m(_size.value),\n  ns.is('error', validateState.value === 'error'),\n  ns.is('validating', validateState.value === 'validating'),\n  ns.is('success', validateState.value === 'success'),\n  ns.is('required', isRequired.value || props.required),\n  ns.is('no-asterisk', formContext?.hideRequiredAsterisk),\n  { [ns.m('feedback')]: formContext?.statusIcon },\n])\n\nconst _inlineMessage = computed(() =>\n  isBoolean(props.inlineMessage)\n    ? props.inlineMessage\n    : formContext?.inlineMessage || false\n)\n\nconst validateClasses = computed(() => [\n  ns.e('error'),\n  { [ns.em('error', 'inline')]: _inlineMessage.value },\n])\n\nconst propString = computed(() => {\n  if (!props.prop) return ''\n  return isString(props.prop) ? props.prop : props.prop.join('.')\n})\n\nconst labelFor = computed(() => props.for || propString.value)\n\nconst isNested = !!parentFormItemContext\n\nconst fieldValue = computed(() => {\n  const model = formContext?.model\n  if (!model || !props.prop) {\n    return\n  }\n  return getProp(model, props.prop).value\n})\n\nconst _rules = computed(() => {\n  const rules: FormItemRule[] = props.rules ? ensureArray(props.rules) : []\n\n  const formRules = formContext?.rules\n  if (formRules && props.prop) {\n    const _rules = getProp<Arrayable<FormItemRule> | undefined>(\n      formRules,\n      props.prop\n    ).value\n    if (_rules) {\n      rules.push(...ensureArray(_rules))\n    }\n  }\n\n  if (props.required !== undefined) {\n    rules.push({ required: !!props.required })\n  }\n\n  return rules\n})\n\nconst validateEnabled = computed(() => _rules.value.length > 0)\n\nconst getFilteredRule = (trigger: string) => {\n  const rules = _rules.value\n  return (\n    rules\n      .filter((rule) => {\n        if (!rule.trigger || !trigger) return true\n        if (Array.isArray(rule.trigger)) {\n          return rule.trigger.includes(trigger)\n        } else {\n          return rule.trigger === trigger\n        }\n      })\n      // exclude trigger\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      .map(({ trigger, ...rule }): RuleItem => rule)\n  )\n}\n\nconst isRequired = computed(() =>\n  _rules.value.some((rule) => rule.required === true)\n)\n\nconst shouldShowError = computed(\n  () =>\n    validateStateDebounced.value === 'error' &&\n    props.showMessage &&\n    (formContext?.showMessage ?? true)\n)\n\nconst currentLabel = computed(\n  () => `${props.label || ''}${formContext?.labelSuffix || ''}`\n)\n\nconst setValidationState = (state: FormItemValidateState) => {\n  validateState.value = state\n}\n\nconst onValidationFailed = (error: FormValidateFailure) => {\n  const { errors, fields } = error\n  if (!errors || !fields) {\n    console.error(error)\n  }\n\n  setValidationState('error')\n  validateMessage.value = errors\n    ? errors?.[0]?.message ?? `${props.prop} is required`\n    : ''\n\n  formContext?.emit('validate', props.prop!, false, validateMessage.value)\n}\n\nconst onValidationSucceeded = () => {\n  setValidationState('success')\n  formContext?.emit('validate', props.prop!, true, '')\n}\n\nconst doValidate = async (rules: RuleItem[]): Promise<true> => {\n  const modelName = propString.value\n  const validator = new AsyncValidator({\n    [modelName]: rules,\n  })\n  return validator\n    .validate({ [modelName]: fieldValue.value }, { firstFields: true })\n    .then(() => {\n      onValidationSucceeded()\n      return true as const\n    })\n    .catch((err: FormValidateFailure) => {\n      onValidationFailed(err as FormValidateFailure)\n      return Promise.reject(err)\n    })\n}\n\nconst validate: FormItemContext['validate'] = async (trigger, callback) => {\n  // skip validation if its resetting\n  if (isResettingField) {\n    isResettingField = false\n    return false\n  }\n\n  const hasCallback = isFunction(callback)\n  if (!validateEnabled.value) {\n    callback?.(false)\n    return false\n  }\n\n  const rules = getFilteredRule(trigger)\n  if (rules.length === 0) {\n    callback?.(true)\n    return true\n  }\n\n  setValidationState('validating')\n\n  return doValidate(rules)\n    .then(() => {\n      callback?.(true)\n      return true as const\n    })\n    .catch((err: FormValidateFailure) => {\n      const { fields } = err\n      callback?.(false, fields)\n      return hasCallback ? false : Promise.reject(fields)\n    })\n}\n\nconst clearValidate: FormItemContext['clearValidate'] = () => {\n  setValidationState('')\n  validateMessage.value = ''\n}\n\nconst resetField: FormItemContext['resetField'] = async () => {\n  const model = formContext?.model\n  if (!model || !props.prop) return\n\n  const computedValue = getProp(model, props.prop)\n\n  if (!isEqual(computedValue.value, initialValue)) {\n    // prevent validation from being triggered\n    isResettingField = true\n  }\n\n  computedValue.value = initialValue\n\n  await nextTick()\n  clearValidate()\n}\n\nwatch(\n  () => props.error,\n  (val) => {\n    validateMessage.value = val || ''\n    setValidationState(val ? 'error' : '')\n  },\n  { immediate: true }\n)\n\nwatch(\n  () => props.validateStatus,\n  (val) => setValidationState(val || '')\n)\n\nconst context: FormItemContext = reactive({\n  ...toRefs(props),\n  $el: formItemRef,\n  size: _size,\n  validateState,\n  resetField,\n  clearValidate,\n  validate,\n})\n\nprovide(formItemContextKey, context)\n\nonMounted(() => {\n  if (props.prop) {\n    formContext?.addField(context)\n    initialValue = clone(fieldValue.value)\n  }\n})\n\nonBeforeUnmount(() => {\n  formContext?.removeField(context)\n})\n\ndefineExpose({\n  /** @description form item size */\n  size: _size,\n  /** @description validation message */\n  validateMessage,\n  /** @description validation state */\n  validateState,\n  /** @description validate form item */\n  validate,\n  /** @description clear validation status */\n  clearValidate,\n  /** @description reset field value */\n  resetField,\n})\n</script>\n","import { withInstall, withNoopInstall } from '@element-plus/utils'\nimport Form from './src/form.vue'\nimport FormItem from './src/form-item.vue'\n\nexport const ElForm = withInstall(Form, {\n  FormItem,\n})\nexport default ElForm\nexport const ElFormItem = withNoopInstall(FormItem)\n\nexport * from './src/form'\nexport * from './src/form-item'\nexport * from './src/types'\n\nexport type FormInstance = InstanceType<typeof Form>\nexport type FormItemInstance = InstanceType<typeof FormItem>\n","import type { Nullable } from '../typescript'\n\nconst FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\"-1\"]),input:not([disabled]),input:not([type=\"hidden\"]),select:not([disabled]),textarea:not([disabled])`\n\n/**\n * Determine if the testing element is visible on screen no matter if its on the viewport or not\n */\nexport const isVisible = (element: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return true\n  const computed = getComputedStyle(element)\n  // element.offsetParent won't work on fix positioned\n  // WARNING: potential issue here, going to need some expert advices on this issue\n  return computed.position === 'fixed' ? false : element.offsetParent !== null\n}\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  return Array.from(\n    element.querySelectorAll<HTMLElement>(FOCUSABLE_ELEMENT_SELECTORS)\n  ).filter((item: HTMLElement) => isFocusable(item) && isVisible(item))\n}\n\n/**\n * @desc Determine if target element is focusable\n * @param element {HTMLElement}\n * @returns {Boolean} true if it is focusable\n */\nexport const isFocusable = (element: HTMLElement): boolean => {\n  if (\n    element.tabIndex > 0 ||\n    (element.tabIndex === 0 && element.getAttribute('tabIndex') !== null)\n  ) {\n    return true\n  }\n  // HTMLButtonElement has disabled\n  if ((element as HTMLButtonElement).disabled) {\n    return false\n  }\n\n  switch (element.nodeName) {\n    case 'A': {\n      // casting current element to Specific HTMLElement in order to be more type precise\n      return (\n        !!(element as HTMLAnchorElement).href &&\n        (element as HTMLAnchorElement).rel !== 'ignore'\n      )\n    }\n    case 'INPUT': {\n      return !(\n        (element as HTMLInputElement).type === 'hidden' ||\n        (element as HTMLInputElement).type === 'file'\n      )\n    }\n    case 'BUTTON':\n    case 'SELECT':\n    case 'TEXTAREA': {\n      return true\n    }\n    default: {\n      return false\n    }\n  }\n}\n\n/**\n * @desc Set Attempt to set focus on the current node.\n * @param element\n *          The node to attempt to focus on.\n * @returns\n *  true if element is focused.\n */\nexport const attemptFocus = (element: HTMLElement): boolean => {\n  if (!isFocusable(element)) {\n    return false\n  }\n  // Remove the old try catch block since there will be no error to be thrown\n  element.focus?.()\n  return document.activeElement === element\n}\n\n/**\n * Trigger an event\n * mouseenter, mouseleave, mouseover, keyup, change, click, etc.\n * @param  {HTMLElement} elm\n * @param  {String} name\n * @param  {*} opts\n */\nexport const triggerEvent = function (\n  elm: HTMLElement,\n  name: string,\n  ...opts: Array<boolean>\n): HTMLElement {\n  let eventName: string\n\n  if (name.includes('mouse') || name.includes('click')) {\n    eventName = 'MouseEvents'\n  } else if (name.includes('key')) {\n    eventName = 'KeyboardEvent'\n  } else {\n    eventName = 'HTMLEvents'\n  }\n  const evt = document.createEvent(eventName)\n\n  evt.initEvent(name, ...opts)\n  elm.dispatchEvent(evt)\n  return elm\n}\n\nexport const isLeaf = (el: HTMLElement) => !el.getAttribute('aria-owns')\n\nexport const getSibling = (\n  el: HTMLElement,\n  distance: number,\n  elClass: string\n): Nullable<Element> => {\n  const { parentNode } = el\n  if (!parentNode) return null\n  const siblings = parentNode.querySelectorAll(elClass)\n  const index = Array.prototype.indexOf.call(siblings, el)\n  return siblings[index + distance] || null\n}\n\nexport const focusNode = (el) => {\n  if (!el) return\n  el.focus()\n  !isLeaf(el) && el.click()\n}\n"],"names":["formProps","buildProps","model","Object","rules","type","definePropType","labelPosition","String","labelWidth","Number","default","labelSuffix","inline","Boolean","inlineMessage","size","values","componentSizes","disabled","validateOnRuleChange","hideRequiredAsterisk","scrollToError","formEmits","prop","isValid","message","isArray","isString","isBoolean","castArray","arguments","length","value","SCOPE","useFormLabelWidth","potentialLabelWidthArr","ref","autoLabelWidth","computed","max","Math","getLabelWidthIndex","width","index","indexOf","debugWarn","registerLabelWidth","val","oldVal","splice","push","deregisterLabelWidth","filterFields","fields","props","normalized","ensureArray","filter","field","includes","ns","validateField","props2","fields3","validationErrors","modelProps","callback","e","scrollToField","watch","validate","deep","provide","reactive","emit","resetFields","clearValidate","addField","removeField","expose","CLONE_SYMBOLS_FLAG","clone","baseClone","formItemValidateStates","formItemProps","label","Array","required","validateStatus","for","showMessage","COMPONENT_NAME","defineComponent","name","isAutoWidth","updateAll","setup","formContext","inject","throwError","useNamespace","el","computedWidth","getLabelWidth","_a","window","getComputedStyle","firstElementChild","ceil","parseFloat","nextTick","action","updateLabelWidthFn","onMounted","onBeforeUnmount","updateLabelWidth","slots","style","marginWidth","parseInt","marginPosition","be","formItem","marginLeft","formRules","rule","trigger","map","_rules","validateState","errors","console","setValidationState","validateMessage","doValidate","firstFields","onValidationSucceeded","catch","err","onValidationFailed","isResettingField","computedValue","initialValue","immediate","$el","resetField","ElForm","withInstall","Form","FormItem","ElFormItem","withNoopInstall","FOCUSABLE_ELEMENT_SELECTORS","isVisible","element","position","offsetParent","obtainAllFocusableElements","from","querySelectorAll","item","isFocusable","tabIndex","getAttribute","nodeName","href","rel","triggerEvent","elm","opts","eventName","evt","document","createEvent","initEvent","dispatchEvent","isLeaf","getSibling","distance","elClass","parentNode","siblings","prototype","call","focusNode","focus","click"],"sourceRoot":""}